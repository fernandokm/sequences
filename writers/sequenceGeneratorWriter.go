package writers

import (
	"errors"
	"fmt"
	"io"

	"github.com/clipperhouse/typewriter"
)

const license = `// Generated by gen with typewriter at github.com/fernandokm/sequences/writers
// GNU GPL 2.0
// Copyright (c) 2015 Fernando Matsumoto (ferkmatsumoto@hotmail.com)
`

var typeTitle = map[string]string{
	"int64":    "Int64",
	"uint64":   "Uint64",
	"float64":  "Float64",
	"*big.Int": "BigInt",
	"*big.Rat": "BigRat",
}

type SequenceGeneratorWriter struct{}

func NewSequenceGeneratorWriter() *SequenceGeneratorWriter {
	return &SequenceGeneratorWriter{}
}

func (sw *SequenceGeneratorWriter) Name() string {
	return "sequenceGenerator"
}

func (sw *SequenceGeneratorWriter) Imports(t typewriter.Type) (result []typewriter.ImportSpec) {
	return result
}

func (sw *SequenceGeneratorWriter) Write(w io.Writer, t typewriter.Type) error {
	tag, found := t.FindTag(sw)
	if !found {
		return nil
	}

	if _, err := w.Write([]byte(license)); err != nil {
		return err
	}

	generatorName := t.Name
	for _, v := range tag.Values {
		switch v.Name {
		case "Iterator":
			if len(v.TypeParameters) == 0 {
				return errors.New("No type parameters for Iterate tag")
			}
			typeParameters := v.TypeParameters
			v.TypeParameters = make([]typewriter.Type, 0)

			tmpl, err := templates.ByTagValue(t, v)
			if err != nil {
				return err
			}
			for _, typ := range typeParameters {
				typeName := typ.Pointer.String() + typ.Name
				if typeName == "*bigInt" {
					typeName = "*big.Int"
				} else if typeName == "*bigRat" {
					typeName = "*bigRat"
				}
				typeTitle := typeTitle[typeName]
				if typeTitle == "" {
					return fmt.Errorf("Unexpected type: %s", typeName)
				}
				tmpl.Execute(w, generatorModel{generatorName, typeName, typeTitle})
			}
			return nil
		default:
			return fmt.Errorf("Unrecognized tag: %s", v.Name)
		}
	}

	return nil
}
